# Порівняння алгоритмів сортування: Merge Sort, Insertion Sort та Timsort

#Мета
Порівняти алгоритми сортування злиттям, вставками та Timsort за часом виконання на різних розмірах масивів та емпірично підтвердити теоретичні оцінки їх складності.

# Аналіз алгоритмів
- **Merge Sort:** Алгоритм сортування злиттям має складність `O(n log n)`. Він досить ефективний, але витрачає більше часу на рекурсію та об’єднання елементів.
- **Insertion Sort:** Алгоритм сортування вставками має складність `O(n^2)`. Підходить лише для малих наборів даних через квадратичну складність.
- **Timsort:** Вбудований в Python алгоритм, який є гібридом сортування злиттям та вставками. Завдяки своїй оптимізації має середню складність `O(n log n)` і працює швидше на практиці.

# Результати порівняння
Результати показують, що Timsort є значно ефективнішим на великих наборах даних порівняно з іншими алгоритмами. Це пояснює, чому Python використовує його як основний алгоритм сортування.

#Висновки
- На малих наборах даних сортування вставками може бути ефективним, але для великих масивів Timsort завжди показує найкращі результати.
- Завдяки поєднанню сортування злиттям та вставками Timsort є швидким та оптимальним вибором у більшості випадків.

# Необов'язкове завдання
Реалізована функція `merge_k_lists` для об’єднання k відсортованих списків у один відсортований.
